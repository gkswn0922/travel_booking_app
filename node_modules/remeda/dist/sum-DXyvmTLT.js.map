{"version":3,"file":"sum-DXyvmTLT.js","names":[],"sources":["../src/sum.ts"],"sourcesContent":["import type { IterableContainer } from \"./internal/types/IterableContainer\";\nimport { purry } from \"./purry\";\n\ntype Sum<T extends IterableContainer<bigint> | IterableContainer<number>> =\n  // Empty arrays would always result in a sum of (a non-bigint) 0.\n  T extends readonly []\n    ? 0\n    : // Non-empty bigint arrays will always result in a bigint sum.\n      T extends readonly [bigint, ...ReadonlyArray<unknown>]\n      ? bigint\n      : // But an empty bigint array would result in a non-bigint 0.\n        T[number] extends bigint\n        ? bigint | 0\n        : // Non-bigint arrays are always handled correctly.\n          number;\n\n/**\n * Sums the numbers in the array, or return 0 for an empty array.\n *\n * Works for both `number` and `bigint` arrays, but not arrays that contain both\n * types.\n *\n * IMPORTANT: The result for empty arrays would be 0 (`number`) regardless of\n * the type of the array; to avoid adding this to the return type for cases\n * where the array is known to be non-empty you can use `hasAtLeast` or\n * `isEmpty` to guard against this case.\n *\n * @param data - The array of numbers.\n * @signature\n *   R.sum(data);\n * @example\n *   R.sum([1, 2, 3]); // => 6\n *   R.sum([1n, 2n, 3n]); // => 6n\n *   R.sum([]); // => 0\n * @dataFirst\n * @category Number\n */\nexport function sum<\n  T extends IterableContainer<bigint> | IterableContainer<number>,\n>(data: T): Sum<T>;\n\n/**\n * Sums the numbers in the array, or return 0 for an empty array.\n *\n * Works for both `number` and `bigint` arrays, but not arrays that contain both\n * types.\n *\n * IMPORTANT: The result for empty arrays would be 0 (`number`) regardless of\n * the type of the array; to avoid adding this to the return type for cases\n * where the array is known to be non-empty you can use `hasAtLeast` or\n * `isEmpty`to guard against this case.\n *\n * @signature\n *   R.sum()(data);\n * @example\n *   R.pipe([1, 2, 3], R.sum()); // => 6\n *   R.pipe([1n, 2n, 3n], R.sum()); // => 6n\n *   R.pipe([], R.sum()); // => 0\n * @dataLast\n * @category Number\n */\nexport function sum(): <\n  T extends IterableContainer<bigint> | IterableContainer<number>,\n>(\n  data: T,\n) => Sum<T>;\n\nexport function sum(...args: ReadonlyArray<unknown>): unknown {\n  return purry(sumImplementation, args);\n}\n\nfunction sumImplementation<\n  T extends IterableContainer<bigint> | IterableContainer<number>,\n>(data: T): T[number] {\n  // eslint-disable-next-line @typescript-eslint/no-magic-numbers -- The rule differentiates 0 and 0n :(\n  let out = typeof data[0] === \"bigint\" ? 0n : 0;\n  for (const value of data) {\n    // @ts-expect-error [ts2365] -- Typescript can't infer that all elements will be a number of the same type.\n    // eslint-disable-next-line @typescript-eslint/restrict-plus-operands\n    out += value;\n  }\n  return out;\n}\n"],"mappings":"4CAmEA,SAAgB,EAAI,GAAG,EAAuC,CAC5D,OAAO,EAAM,EAAmB,EAAK,CAGvC,SAAS,EAEP,EAAoB,CAEpB,IAAI,EAAM,OAAO,EAAK,IAAO,SAAW,GAAK,EAC7C,IAAK,IAAM,KAAS,EAGlB,GAAO,EAET,OAAO"}