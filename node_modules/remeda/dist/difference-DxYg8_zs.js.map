{"version":3,"file":"difference-DxYg8_zs.js","names":[],"sources":["../src/difference.ts"],"sourcesContent":["import { purryFromLazy } from \"./internal/purryFromLazy\";\nimport type { LazyEvaluator } from \"./internal/types/LazyEvaluator\";\nimport { SKIP_ITEM, lazyIdentityEvaluator } from \"./internal/utilityEvaluators\";\n\n/**\n * Excludes the values from `other` array. The output maintains the same order\n * as the input. The inputs are treated as multi-sets/bags (multiple copies of\n * items are treated as unique items).\n *\n * @param data - The input items.\n * @param other - The values to exclude.\n * @signature\n *    R.difference(data, other)\n * @example\n *    R.difference([1, 2, 3, 4], [2, 5, 3]); // => [1, 4]\n *    R.difference([1, 1, 2, 2], [1]); // => [1, 2, 2]\n * @dataFirst\n * @lazy\n * @category Array\n */\nexport function difference<T>(\n  data: ReadonlyArray<T>,\n  other: ReadonlyArray<T>,\n): Array<T>;\n\n/**\n * Excludes the values from `other` array. The output maintains the same order\n * as the input. The inputs are treated as multi-sets/bags (multiple copies of\n * items are treated as unique items).\n *\n * @param other - The values to exclude.\n * @signature\n *    R.difference(other)(data)\n * @example\n *    R.pipe([1, 2, 3, 4], R.difference([2, 5, 3])); // => [1, 4]\n *    R.pipe([1, 1, 2, 2], R.difference([1])); // => [1, 2, 2]\n * @dataFirst\n * @lazy\n * @category Array\n */\nexport function difference<T>(\n  other: ReadonlyArray<T>,\n): (data: ReadonlyArray<T>) => Array<T>;\n\nexport function difference(...args: ReadonlyArray<unknown>): unknown {\n  return purryFromLazy(lazyImplementation, args);\n}\n\nfunction lazyImplementation<T>(other: ReadonlyArray<T>): LazyEvaluator<T> {\n  if (other.length === 0) {\n    return lazyIdentityEvaluator;\n  }\n\n  // We need to build a more efficient data structure that would allow us to\n  // keep track of the number of times we've seen a value in the other array.\n  const remaining = new Map<T, number>();\n  for (const value of other) {\n    remaining.set(value, (remaining.get(value) ?? 0) + 1);\n  }\n\n  return (value) => {\n    const copies = remaining.get(value);\n\n    if (copies === undefined || copies === 0) {\n      // The item is either not part of the other array or we've dropped enough\n      // copies of it so we return it.\n      return { done: false, hasNext: true, next: value };\n    }\n\n    // The item is equal to an item in the other array and there are still\n    // copies of it to \"account\" for so we skip this one and remove it from our\n    // ongoing tally.\n    remaining.set(value, copies - 1);\n    return SKIP_ITEM;\n  };\n}\n"],"mappings":"mJA4CA,SAAgB,EAAW,GAAG,EAAuC,CACnE,OAAO,EAAc,EAAoB,EAAK,CAGhD,SAAS,EAAsB,EAA2C,CACxE,GAAI,EAAM,SAAW,EACnB,OAAO,EAKT,IAAM,EAAY,IAAI,IACtB,IAAK,IAAM,KAAS,EAClB,EAAU,IAAI,GAAQ,EAAU,IAAI,EAAM,EAAI,GAAK,EAAE,CAGvD,MAAQ,IAAU,CAChB,IAAM,EAAS,EAAU,IAAI,EAAM,CAYnC,OAVI,IAAW,IAAA,IAAa,IAAW,EAG9B,CAAE,KAAM,GAAO,QAAS,GAAM,KAAM,EAAO,EAMpD,EAAU,IAAI,EAAO,EAAS,EAAE,CACzB"}