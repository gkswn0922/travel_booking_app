{"version":3,"file":"flatMap-Cw4Hh6bl.js","names":[],"sources":["../src/flatMap.ts"],"sourcesContent":["import type { LazyEvaluator } from \"./internal/types/LazyEvaluator\";\nimport { purry } from \"./purry\";\n\n/**\n * Returns a new array formed by applying a given callback function to each\n * element of the array, and then flattening the result by one level. It is\n * identical to a `map` followed by a `flat` of depth 1\n * (`flat(map(data, ...args))`), but slightly more efficient than calling those\n * two methods separately. Equivalent to `Array.prototype.flatMap`.\n *\n * @param data - The items to map and flatten.\n * @param callbackfn - A function to execute for each element in the array. It\n * should return an array containing new elements of the new array, or a single\n * non-array value to be added to the new array.\n * @returns A new array with each element being the result of the callback\n * function and flattened by a depth of 1.\n * @signature\n *    R.flatMap(data, callbackfn)\n * @example\n *    R.flatMap([1, 2, 3], x => [x, x * 10]) // => [1, 10, 2, 20, 3, 30]\n * @dataFirst\n * @lazy\n * @category Array\n */\nexport function flatMap<T, U>(\n  data: ReadonlyArray<T>,\n  callbackfn: (\n    input: T,\n    index: number,\n    data: ReadonlyArray<T>,\n  ) => ReadonlyArray<U> | U,\n): Array<U>;\n\n/**\n * Returns a new array formed by applying a given callback function to each\n * element of the array, and then flattening the result by one level. It is\n * identical to a `map` followed by a `flat` of depth 1\n * (`flat(map(data, ...args))`), but slightly more efficient than calling those\n * two methods separately. Equivalent to `Array.prototype.flatMap`.\n *\n * @param callbackfn - A function to execute for each element in the array. It\n * should return an array containing new elements of the new array, or a single\n * non-array value to be added to the new array.\n * @returns A new array with each element being the result of the callback\n * function and flattened by a depth of 1.\n * @signature\n *    R.flatMap(callbackfn)(data)\n * @example\n *    R.pipe([1, 2, 3], R.flatMap(x => [x, x * 10])) // => [1, 10, 2, 20, 3, 30]\n * @dataLast\n * @lazy\n * @category Array\n */\nexport function flatMap<T, U>(\n  callbackfn: (\n    input: T,\n    index: number,\n    data: ReadonlyArray<T>,\n  ) => ReadonlyArray<U> | U,\n): (data: ReadonlyArray<T>) => Array<U>;\n\nexport function flatMap(...args: ReadonlyArray<unknown>): unknown {\n  return purry(flatMapImplementation, args, lazyImplementation);\n}\n\nconst flatMapImplementation = <T, U>(\n  data: ReadonlyArray<T>,\n  callbackfn: (\n    value: T,\n    index: number,\n    data: ReadonlyArray<T>,\n  ) => ReadonlyArray<U> | U,\n): Array<U> => data.flatMap(callbackfn);\n\nconst lazyImplementation =\n  <T, K>(\n    callbackfn: (\n      input: T,\n      index: number,\n      data: ReadonlyArray<T>,\n    ) => K | ReadonlyArray<K>,\n  ): LazyEvaluator<T, K> =>\n  // @ts-expect-error [ts2322] - We need to make LazyMany better so it accommodate the typing here...\n  (value, index, data) => {\n    const next = callbackfn(value, index, data);\n    return Array.isArray(next)\n      ? { done: false, hasNext: true, hasMany: true, next }\n      : { done: false, hasNext: true, next };\n  };\n"],"mappings":"4CA6DA,SAAgB,EAAQ,GAAG,EAAuC,CAChE,OAAO,EAAM,EAAuB,EAAM,EAAmB,CAG/D,MAAM,GACJ,EACA,IAKa,EAAK,QAAQ,EAAW,CAEjC,EAEF,IAOD,EAAO,EAAO,IAAS,CACtB,IAAM,EAAO,EAAW,EAAO,EAAO,EAAK,CAC3C,OAAO,MAAM,QAAQ,EAAK,CACtB,CAAE,KAAM,GAAO,QAAS,GAAM,QAAS,GAAM,OAAM,CACnD,CAAE,KAAM,GAAO,QAAS,GAAM,OAAM"}