{"version":3,"file":"conditional-BdGnwdZr.js","names":[],"sources":["../src/internal/purryOn.ts","../src/conditional.ts"],"sourcesContent":["/**\n * Utility for purrying functions based on a predicate for the first argument.\n *\n * This is useful for purrying functions with a variadic argument list.\n */\nexport function purryOn<T>(\n  isArg: (firstArg: unknown) => firstArg is T,\n  implementation: (\n    data: unknown,\n    firstArg: T,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any -- Function inference in typescript relies on `any` to work, it doesn't work with `unknown`\n    ...args: any\n  ) => unknown,\n  args: ReadonlyArray<unknown>,\n): unknown {\n  return isArg(args[0])\n    ? // @ts-expect-error [ts2556] - This is a low-level function that assumes the function declaration and setup is correct and won't result in typing issues when called dynamically.\n      (data: unknown) => implementation(data, ...args)\n    : // @ts-expect-error [ts2556] - This is a low-level function that assumes the function declaration and setup is correct and won't result in typing issues when called dynamically.\n      implementation(...args);\n}\n","/* eslint-disable jsdoc/check-param-names, jsdoc/require-param --\n * We don't document each `case` param, instead we document the concept more\n * generally, but these eslint rules can't detect that.\n */\n\nimport { purryOn } from \"./internal/purryOn\";\nimport type { GuardType } from \"./internal/types/GuardType\";\n\ntype Case<\n  In,\n  Out,\n  When extends (x: In) => boolean = (x: In) => boolean,\n> = readonly [when: When, then: (x: GuardType<When, In> & In) => Out];\n\ntype DefaultCase<In, Out> = (x: In) => Out;\n\n/**\n * Executes a transformer function based on the first matching predicate,\n * functioning like a series of `if...else if...` statements. It sequentially\n * evaluates each case and, upon finding a truthy predicate, runs the\n * corresponding transformer, and returns, ignoring any further cases, even if\n * they would match.\n *\n * *NOTE*: Some type-predicates may fail to narrow the param type of their\n * transformer; in such cases wrap your type-predicate in an anonymous arrow\n * function: e.g., instead of\n * `conditional(..., [myTypePredicate, myTransformer], ...)`, use\n * `conditional(..., [($) => myTypePredicate($), myTransformer], ...)`.\n *\n * To add a a default, catch-all, case you can provide a single callback\n * function (instead of a 2-tuple) as the last case. This is equivalent to\n * adding a case with a trivial always-true predicate as it's condition (see\n * example).\n *\n * For simpler cases you should also consider using `when` instead.\n *\n * Due to TypeScript's inability to infer the result of negating a type-\n * predicate we can't refine the types used in subsequent cases based on\n * previous conditions. Using a `switch (true)` statement or ternary operators\n * is recommended for more precise type control when such type narrowing is\n * needed.\n *\n * !IMPORTANT! - Unlike similar implementations in Lodash and Ramda, the Remeda\n * implementation **doesn't** implicitly return `undefined` as a fallback when\n * when none of the cases match; and instead **throws** an exception in those\n * cases! You have to explicitly provide a default case, and can use\n * `constant(undefined)` as your last case to replicate that behavior.\n *\n * @param cases - A list of (up to 10) cases. Each case can be either:\n * - A 2-tuple consisting of a predicate (or type-predicate) and a transformer\n *   function that processes the data if the predicate matches.\n * - A single callback function that acts as a default fallback case.\n * @returns The output of the matched transformer. If no cases match, an\n * exception is thrown. The return type is a union of the return types of all\n * provided transformers.\n * @signature\n *   R.conditional(...cases)(data);\n * @example\n *   const nameOrId = 3 as string | number | boolean;\n *\n *   R.pipe(\n *     nameOrId,\n *     R.conditional(\n *       [R.isString, (name) => `Hello ${name}`],\n *       [R.isNumber, (id) => `Hello ID: ${id}`],\n *     ),\n *   ); //=> 'Hello ID: 3' (typed as `string`), can throw!.\n *\n *   R.pipe(\n *     nameOrId,\n *     R.conditional(\n *       [R.isString, (name) => `Hello ${name}`],\n *       [R.isNumber, (id) => `Hello ID: ${id}`],\n *       R.constant(undefined),\n *     ),\n *   ); //=> 'Hello ID: 3' (typed as `string | undefined`), won't throw.\n *\n *   R.pipe(\n *     nameOrId,\n *     R.conditional(\n *       [R.isString, (name) => `Hello ${name}`],\n *       [R.isNumber, (id) => `Hello ID: ${id}`],\n *       (something) => `Hello something (${JSON.stringify(something)})`,\n *     ),\n *   ); //=> 'Hello ID: 3' (typed as `string`), won't throw.\n * @dataLast\n * @category Function\n */\nexport function conditional<\n  T,\n  Fn0 extends (x: T) => boolean,\n  Return0,\n  Fallback = never,\n>(\n  // TODO [>2]: TypeScript has problems inferring narrowed types within the case tuples, making it hard to work with this utility. Removing the tuple wrappers solves these issues without impacting the API too much. @see https://github.com/remeda/remeda/issues/847#issuecomment-3057371891\n  case0: Case<T, Return0, Fn0>,\n  fallback?: DefaultCase<T, Fallback>,\n): (data: T) => Return0 | Fallback;\n\nexport function conditional<\n  T,\n  Fn0 extends (x: T) => boolean,\n  // TODO [>2]: Exclude previous guarded types from the next functions in the chain. Although this isn't a prefect solution, it's the common approach to compute the \"negation\" of a type-predicate, and would provide a more comfortable API for bigger chains for cases like discriminated unions. This TODO is at the first occurrence where it is relevant, but it should be applied to **all** subsequent overloads. p.s. don't forget to update the docs too!\n  Fn1 extends (x: T) => boolean,\n  Return0,\n  Return1,\n  Fallback = never,\n>(\n  case0: Case<T, Return0, Fn0>,\n  case1: Case<T, Return1, Fn1>,\n  fallback?: DefaultCase<T, Fallback>,\n): (data: T) => Return0 | Return1 | Fallback;\n\nexport function conditional<\n  T,\n  Fn0 extends (x: T) => boolean,\n  Fn1 extends (x: T) => boolean,\n  Fn2 extends (x: T) => boolean,\n  Return0,\n  Return1,\n  Return2,\n  Fallback = never,\n>(\n  case0: Case<T, Return0, Fn0>,\n  case1: Case<T, Return1, Fn1>,\n  case2: Case<T, Return2, Fn2>,\n  fallback?: DefaultCase<T, Fallback>,\n): (data: T) => Return0 | Return1 | Return2 | Fallback;\n\nexport function conditional<\n  T,\n  Fn0 extends (x: T) => boolean,\n  Fn1 extends (x: T) => boolean,\n  Fn2 extends (x: T) => boolean,\n  Fn3 extends (x: T) => boolean,\n  Return0,\n  Return1,\n  Return2,\n  Return3,\n  Fallback = never,\n>(\n  case0: Case<T, Return0, Fn0>,\n  case1: Case<T, Return1, Fn1>,\n  case2: Case<T, Return2, Fn2>,\n  case3: Case<T, Return3, Fn3>,\n  fallback?: DefaultCase<T, Fallback>,\n): (data: T) => Return0 | Return1 | Return2 | Return3 | Fallback;\n\nexport function conditional<\n  T,\n  Fn0 extends (x: T) => boolean,\n  Fn1 extends (x: T) => boolean,\n  Fn2 extends (x: T) => boolean,\n  Fn3 extends (x: T) => boolean,\n  Fn4 extends (x: T) => boolean,\n  Return0,\n  Return1,\n  Return2,\n  Return3,\n  Return4,\n  Fallback = never,\n>(\n  case0: Case<T, Return0, Fn0>,\n  case1: Case<T, Return1, Fn1>,\n  case2: Case<T, Return2, Fn2>,\n  case3: Case<T, Return3, Fn3>,\n  case4: Case<T, Return4, Fn4>,\n  fallback?: DefaultCase<T, Fallback>,\n): (data: T) => Return0 | Return1 | Return2 | Return3 | Return4 | Fallback;\n\nexport function conditional<\n  T,\n  Fn0 extends (x: T) => boolean,\n  Fn1 extends (x: T) => boolean,\n  Fn2 extends (x: T) => boolean,\n  Fn3 extends (x: T) => boolean,\n  Fn4 extends (x: T) => boolean,\n  Fn5 extends (x: T) => boolean,\n  Return0,\n  Return1,\n  Return2,\n  Return3,\n  Return4,\n  Return5,\n  Fallback = never,\n>(\n  case0: Case<T, Return0, Fn0>,\n  case1: Case<T, Return1, Fn1>,\n  case2: Case<T, Return2, Fn2>,\n  case3: Case<T, Return3, Fn3>,\n  case4: Case<T, Return4, Fn4>,\n  case5: Case<T, Return5, Fn5>,\n  fallback?: DefaultCase<T, Fallback>,\n): (\n  data: T,\n) => Return0 | Return1 | Return2 | Return3 | Return4 | Return5 | Fallback;\n\nexport function conditional<\n  T,\n  Fn0 extends (x: T) => boolean,\n  Fn1 extends (x: T) => boolean,\n  Fn2 extends (x: T) => boolean,\n  Fn3 extends (x: T) => boolean,\n  Fn4 extends (x: T) => boolean,\n  Fn5 extends (x: T) => boolean,\n  Fn6 extends (x: T) => boolean,\n  Return0,\n  Return1,\n  Return2,\n  Return3,\n  Return4,\n  Return5,\n  Return6,\n  Fallback = never,\n>(\n  case0: Case<T, Return0, Fn0>,\n  case1: Case<T, Return1, Fn1>,\n  case2: Case<T, Return2, Fn2>,\n  case3: Case<T, Return3, Fn3>,\n  case4: Case<T, Return4, Fn4>,\n  case5: Case<T, Return5, Fn5>,\n  case6: Case<T, Return6, Fn6>,\n  fallback?: DefaultCase<T, Fallback>,\n): (\n  data: T,\n) =>\n  | Return0\n  | Return1\n  | Return2\n  | Return3\n  | Return4\n  | Return5\n  | Return6\n  | Fallback;\n\nexport function conditional<\n  T,\n  Fn0 extends (x: T) => boolean,\n  Fn1 extends (x: T) => boolean,\n  Fn2 extends (x: T) => boolean,\n  Fn3 extends (x: T) => boolean,\n  Fn4 extends (x: T) => boolean,\n  Fn5 extends (x: T) => boolean,\n  Fn6 extends (x: T) => boolean,\n  Fn7 extends (x: T) => boolean,\n  Return0,\n  Return1,\n  Return2,\n  Return3,\n  Return4,\n  Return5,\n  Return6,\n  Return7,\n  Fallback = never,\n>(\n  case0: Case<T, Return0, Fn0>,\n  case1: Case<T, Return1, Fn1>,\n  case2: Case<T, Return2, Fn2>,\n  case3: Case<T, Return3, Fn3>,\n  case4: Case<T, Return4, Fn4>,\n  case5: Case<T, Return5, Fn5>,\n  case6: Case<T, Return6, Fn6>,\n  case7: Case<T, Return7, Fn7>,\n  fallback?: DefaultCase<T, Fallback>,\n): (\n  data: T,\n) =>\n  | Return0\n  | Return1\n  | Return2\n  | Return3\n  | Return4\n  | Return5\n  | Return6\n  | Return7\n  | Fallback;\n\nexport function conditional<\n  T,\n  Fn0 extends (x: T) => boolean,\n  Fn1 extends (x: T) => boolean,\n  Fn2 extends (x: T) => boolean,\n  Fn3 extends (x: T) => boolean,\n  Fn4 extends (x: T) => boolean,\n  Fn5 extends (x: T) => boolean,\n  Fn6 extends (x: T) => boolean,\n  Fn7 extends (x: T) => boolean,\n  Fn8 extends (x: T) => boolean,\n  Return0,\n  Return1,\n  Return2,\n  Return3,\n  Return4,\n  Return5,\n  Return6,\n  Return7,\n  Return8,\n  Fallback = never,\n>(\n  case0: Case<T, Return0, Fn0>,\n  case1: Case<T, Return1, Fn1>,\n  case2: Case<T, Return2, Fn2>,\n  case3: Case<T, Return3, Fn3>,\n  case4: Case<T, Return4, Fn4>,\n  case5: Case<T, Return5, Fn5>,\n  case6: Case<T, Return6, Fn6>,\n  case7: Case<T, Return7, Fn7>,\n  case8: Case<T, Return8, Fn8>,\n  fallback?: DefaultCase<T, Fallback>,\n): (\n  data: T,\n) =>\n  | Return0\n  | Return1\n  | Return2\n  | Return3\n  | Return4\n  | Return5\n  | Return6\n  | Return7\n  | Return8\n  | Fallback;\n\nexport function conditional<\n  T,\n  Fn0 extends (x: T) => boolean,\n  Fn1 extends (x: T) => boolean,\n  Fn2 extends (x: T) => boolean,\n  Fn3 extends (x: T) => boolean,\n  Fn4 extends (x: T) => boolean,\n  Fn5 extends (x: T) => boolean,\n  Fn6 extends (x: T) => boolean,\n  Fn7 extends (x: T) => boolean,\n  Fn8 extends (x: T) => boolean,\n  Fn9 extends (x: T) => boolean,\n  Return0,\n  Return1,\n  Return2,\n  Return3,\n  Return4,\n  Return5,\n  Return6,\n  Return7,\n  Return8,\n  Return9,\n  Fallback = never,\n>(\n  case0: Case<T, Return0, Fn0>,\n  case1: Case<T, Return1, Fn1>,\n  case2: Case<T, Return2, Fn2>,\n  case3: Case<T, Return3, Fn3>,\n  case4: Case<T, Return4, Fn4>,\n  case5: Case<T, Return5, Fn5>,\n  case6: Case<T, Return6, Fn6>,\n  case7: Case<T, Return7, Fn7>,\n  case8: Case<T, Return8, Fn8>,\n  case9: Case<T, Return9, Fn9>,\n  fallback?: DefaultCase<T, Fallback>,\n): (\n  data: T,\n) =>\n  | Return0\n  | Return1\n  | Return2\n  | Return3\n  | Return4\n  | Return5\n  | Return6\n  | Return7\n  | Return8\n  | Return9\n  | Fallback;\n\n/**\n * Executes a transformer function based on the first matching predicate,\n * functioning like a series of `if...else if...` statements. It sequentially\n * evaluates each case and, upon finding a truthy predicate, runs the\n * corresponding transformer, and returns, ignoring any further cases, even if\n * they would match.\n *\n * *NOTE*: Some type-predicates may fail to narrow the param type of their\n * transformer; in such cases wrap your type-predicate in an anonymous arrow\n * function: e.g., instead of\n * `conditional(..., [myTypePredicate, myTransformer], ...)`, use\n * `conditional(..., [($) => myTypePredicate($), myTransformer], ...)`.\n *\n * To add a a default, catch-all, case you can provide a single callback\n * function (instead of a 2-tuple) as the last case. This is equivalent to\n * adding a case with a trivial always-true predicate as it's condition (see\n * example).\n *\n * For simpler cases you should also consider using `when` instead.\n *\n * Due to TypeScript's inability to infer the result of negating a type-\n * predicate we can't refine the types used in subsequent cases based on\n * previous conditions. Using a `switch (true)` statement or ternary operators\n * is recommended for more precise type control when such type narrowing is\n * needed.\n *\n * !IMPORTANT! - Unlike similar implementations in Lodash and Ramda, the Remeda\n * implementation **doesn't** implicitly return `undefined` as a fallback when\n * when none of the cases match; and instead **throws** an exception in those\n * cases! You have to explicitly provide a default case, and can use\n * `constant(undefined)` as your last case to replicate that behavior.\n *\n * @param data - The input data to be evaluated against the provided cases.\n * @param cases - A list of (up to 10) cases. Each case can be either:\n * - A 2-tuple consisting of a predicate (or type-predicate) and a transformer\n *   function that processes the data if the predicate matches.\n * - A single callback function that acts as a default fallback case.\n * @returns The output of the matched transformer. If no cases match, an\n * exception is thrown. The return type is a union of the return types of all\n * provided transformers.\n * @signature\n *   R.conditional(data, ...cases);\n * @example\n *   const nameOrId = 3 as string | number | boolean;\n *\n *   R.conditional(\n *     nameOrId,\n *     [R.isString, (name) => `Hello ${name}`],\n *     [R.isNumber, (id) => `Hello ID: ${id}`],\n *   ); //=> 'Hello ID: 3' (typed as `string`), can throw!.\n *\n *   R.conditional(\n *     nameOrId,\n *     [R.isString, (name) => `Hello ${name}`],\n *     [R.isNumber, (id) => `Hello ID: ${id}`],\n *     R.constant(undefined),\n *   ); //=> 'Hello ID: 3' (typed as `string | undefined`), won't throw.\n *\n *   R.conditional(\n *     nameOrId,\n *     [R.isString, (name) => `Hello ${name}`],\n *     [R.isNumber, (id) => `Hello ID: ${id}`],\n *     (something) => `Hello something (${JSON.stringify(something)})`,\n *   ); //=> 'Hello ID: 3' (typed as `string`), won't throw.\n * @dataFirst\n * @category Function\n */\nexport function conditional<\n  T,\n  Fn0 extends (x: T) => boolean,\n  Return0,\n  Fallback = never,\n>(\n  data: T,\n  case0: Case<T, Return0, Fn0>,\n  fallback?: DefaultCase<T, Fallback>,\n): Return0 | Fallback;\n\nexport function conditional<\n  T,\n  Fn0 extends (x: T) => boolean,\n  Fn1 extends (x: T) => boolean,\n  Return0,\n  Return1,\n  Fallback = never,\n>(\n  data: T,\n  case0: Case<T, Return0, Fn0>,\n  case1: Case<T, Return1, Fn1>,\n  fallback?: DefaultCase<T, Fallback>,\n): Return0 | Return1 | Fallback;\n\nexport function conditional<\n  T,\n  Fn0 extends (x: T) => boolean,\n  Fn1 extends (x: T) => boolean,\n  Fn2 extends (x: T) => boolean,\n  Return0,\n  Return1,\n  Return2,\n  Fallback = never,\n>(\n  data: T,\n  case0: Case<T, Return0, Fn0>,\n  case1: Case<T, Return1, Fn1>,\n  case2: Case<T, Return2, Fn2>,\n  fallback?: DefaultCase<T, Fallback>,\n): Return0 | Return1 | Return2 | Fallback;\n\nexport function conditional<\n  T,\n  Fn0 extends (x: T) => boolean,\n  Fn1 extends (x: T) => boolean,\n  Fn2 extends (x: T) => boolean,\n  Fn3 extends (x: T) => boolean,\n  Return0,\n  Return1,\n  Return2,\n  Return3,\n  Fallback = never,\n>(\n  data: T,\n  case0: Case<T, Return0, Fn0>,\n  case1: Case<T, Return1, Fn1>,\n  case2: Case<T, Return2, Fn2>,\n  case3: Case<T, Return3, Fn3>,\n  fallback?: DefaultCase<T, Fallback>,\n): Return0 | Return1 | Return2 | Return3 | Fallback;\n\nexport function conditional<\n  T,\n  Fn0 extends (x: T) => boolean,\n  Fn1 extends (x: T) => boolean,\n  Fn2 extends (x: T) => boolean,\n  Fn3 extends (x: T) => boolean,\n  Fn4 extends (x: T) => boolean,\n  Return0,\n  Return1,\n  Return2,\n  Return3,\n  Return4,\n  Fallback = never,\n>(\n  data: T,\n  case0: Case<T, Return0, Fn0>,\n  case1: Case<T, Return1, Fn1>,\n  case2: Case<T, Return2, Fn2>,\n  case3: Case<T, Return3, Fn3>,\n  case4: Case<T, Return4, Fn4>,\n  fallback?: DefaultCase<T, Fallback>,\n): Return0 | Return1 | Return2 | Return3 | Return4 | Fallback;\n\nexport function conditional<\n  T,\n  Fn0 extends (x: T) => boolean,\n  Fn1 extends (x: T) => boolean,\n  Fn2 extends (x: T) => boolean,\n  Fn3 extends (x: T) => boolean,\n  Fn4 extends (x: T) => boolean,\n  Fn5 extends (x: T) => boolean,\n  Return0,\n  Return1,\n  Return2,\n  Return3,\n  Return4,\n  Return5,\n  Fallback = never,\n>(\n  data: T,\n  case0: Case<T, Return0, Fn0>,\n  case1: Case<T, Return1, Fn1>,\n  case2: Case<T, Return2, Fn2>,\n  case3: Case<T, Return3, Fn3>,\n  case4: Case<T, Return4, Fn4>,\n  case5: Case<T, Return5, Fn5>,\n  fallback?: DefaultCase<T, Fallback>,\n): Return0 | Return1 | Return2 | Return3 | Return4 | Return5 | Fallback;\n\nexport function conditional<\n  T,\n  Fn0 extends (x: T) => boolean,\n  Fn1 extends (x: T) => boolean,\n  Fn2 extends (x: T) => boolean,\n  Fn3 extends (x: T) => boolean,\n  Fn4 extends (x: T) => boolean,\n  Fn5 extends (x: T) => boolean,\n  Fn6 extends (x: T) => boolean,\n  Return0,\n  Return1,\n  Return2,\n  Return3,\n  Return4,\n  Return5,\n  Return6,\n  Fallback = never,\n>(\n  data: T,\n  case0: Case<T, Return0, Fn0>,\n  case1: Case<T, Return1, Fn1>,\n  case2: Case<T, Return2, Fn2>,\n  case3: Case<T, Return3, Fn3>,\n  case4: Case<T, Return4, Fn4>,\n  case5: Case<T, Return5, Fn5>,\n  case6: Case<T, Return6, Fn6>,\n  fallback?: DefaultCase<T, Fallback>,\n):\n  | Return0\n  | Return1\n  | Return2\n  | Return3\n  | Return4\n  | Return5\n  | Return6\n  | Fallback;\n\nexport function conditional<\n  T,\n  Fn0 extends (x: T) => boolean,\n  Fn1 extends (x: T) => boolean,\n  Fn2 extends (x: T) => boolean,\n  Fn3 extends (x: T) => boolean,\n  Fn4 extends (x: T) => boolean,\n  Fn5 extends (x: T) => boolean,\n  Fn6 extends (x: T) => boolean,\n  Fn7 extends (x: T) => boolean,\n  Return0,\n  Return1,\n  Return2,\n  Return3,\n  Return4,\n  Return5,\n  Return6,\n  Return7,\n  Fallback = never,\n>(\n  data: T,\n  case0: Case<T, Return0, Fn0>,\n  case1: Case<T, Return1, Fn1>,\n  case2: Case<T, Return2, Fn2>,\n  case3: Case<T, Return3, Fn3>,\n  case4: Case<T, Return4, Fn4>,\n  case5: Case<T, Return5, Fn5>,\n  case6: Case<T, Return6, Fn6>,\n  case7: Case<T, Return7, Fn7>,\n  fallback?: DefaultCase<T, Fallback>,\n):\n  | Return0\n  | Return1\n  | Return2\n  | Return3\n  | Return4\n  | Return5\n  | Return6\n  | Return7\n  | Fallback;\n\nexport function conditional<\n  T,\n  Fn0 extends (x: T) => boolean,\n  Fn1 extends (x: T) => boolean,\n  Fn2 extends (x: T) => boolean,\n  Fn3 extends (x: T) => boolean,\n  Fn4 extends (x: T) => boolean,\n  Fn5 extends (x: T) => boolean,\n  Fn6 extends (x: T) => boolean,\n  Fn7 extends (x: T) => boolean,\n  Fn8 extends (x: T) => boolean,\n  Return0,\n  Return1,\n  Return2,\n  Return3,\n  Return4,\n  Return5,\n  Return6,\n  Return7,\n  Return8,\n  Fallback = never,\n>(\n  data: T,\n  case0: Case<T, Return0, Fn0>,\n  case1: Case<T, Return1, Fn1>,\n  case2: Case<T, Return2, Fn2>,\n  case3: Case<T, Return3, Fn3>,\n  case4: Case<T, Return4, Fn4>,\n  case5: Case<T, Return5, Fn5>,\n  case6: Case<T, Return6, Fn6>,\n  case7: Case<T, Return7, Fn7>,\n  case8: Case<T, Return8, Fn8>,\n  fallback?: DefaultCase<T, Fallback>,\n):\n  | Return0\n  | Return1\n  | Return2\n  | Return3\n  | Return4\n  | Return5\n  | Return6\n  | Return7\n  | Return8\n  | Fallback;\n\nexport function conditional<\n  T,\n  Fn0 extends (x: T) => boolean,\n  Fn1 extends (x: T) => boolean,\n  Fn2 extends (x: T) => boolean,\n  Fn3 extends (x: T) => boolean,\n  Fn4 extends (x: T) => boolean,\n  Fn5 extends (x: T) => boolean,\n  Fn6 extends (x: T) => boolean,\n  Fn7 extends (x: T) => boolean,\n  Fn8 extends (x: T) => boolean,\n  Fn9 extends (x: T) => boolean,\n  Return0,\n  Return1,\n  Return2,\n  Return3,\n  Return4,\n  Return5,\n  Return6,\n  Return7,\n  Return8,\n  Return9,\n  Fallback = never,\n>(\n  data: T,\n  case0: Case<T, Return0, Fn0>,\n  case1: Case<T, Return1, Fn1>,\n  case2: Case<T, Return2, Fn2>,\n  case3: Case<T, Return3, Fn3>,\n  case4: Case<T, Return4, Fn4>,\n  case5: Case<T, Return5, Fn5>,\n  case6: Case<T, Return6, Fn6>,\n  case7: Case<T, Return7, Fn7>,\n  case8: Case<T, Return8, Fn8>,\n  case9: Case<T, Return9, Fn9>,\n  fallback?: DefaultCase<T, Fallback>,\n):\n  | Return0\n  | Return1\n  | Return2\n  | Return3\n  | Return4\n  | Return5\n  | Return6\n  | Return7\n  | Return8\n  | Return9\n  | Fallback;\n\nexport function conditional(...args: ReadonlyArray<unknown>): unknown {\n  return purryOn(isCase, conditionalImplementation, args);\n}\n\nfunction conditionalImplementation<In, Out>(\n  data: In,\n  ...cases: ReadonlyArray<Case<In, Out> | DefaultCase<In, Out>>\n): Out {\n  for (const current of cases) {\n    if (typeof current === \"function\") {\n      return current(data);\n    }\n\n    const [when, then] = current;\n    if (when(data)) {\n      return then(data);\n    }\n  }\n\n  // TODO [>2]: When we built this function originally we didn't want to have to always return `undefined` and force users to always have to handle that case even when they knew it would never happen. In hindsight that was wrong and we can support this at the type-level without throwing. If users want to throw they can always have an explicit fallback that does that (and we might add a throw utility in v3 too!).\n  throw new Error(\"conditional: data failed for all cases\");\n}\n\nfunction isCase(maybeCase: unknown): maybeCase is Case<unknown, unknown> {\n  if (!Array.isArray(maybeCase)) {\n    return false;\n  }\n\n  const [when, then, ...rest] = maybeCase as ReadonlyArray<unknown>;\n  return (\n    typeof when === \"function\" &&\n    when.length <= 1 &&\n    typeof then === \"function\" &&\n    then.length <= 1 &&\n    rest.length === 0\n  );\n}\n"],"mappings":"AAKA,SAAgB,EACd,EACA,EAMA,EACS,CACT,OAAO,EAAM,EAAK,GAAG,CAEhB,GAAkB,EAAe,EAAM,GAAG,EAAK,CAEhD,EAAe,GAAG,EAAK,CCgsB7B,SAAgB,EAAY,GAAG,EAAuC,CACpE,OAAO,EAAQ,EAAQ,EAA2B,EAAK,CAGzD,SAAS,EACP,EACA,GAAG,EACE,CACL,IAAK,IAAM,KAAW,EAAO,CAC3B,GAAI,OAAO,GAAY,WACrB,OAAO,EAAQ,EAAK,CAGtB,GAAM,CAAC,EAAM,GAAQ,EACrB,GAAI,EAAK,EAAK,CACZ,OAAO,EAAK,EAAK,CAKrB,MAAU,MAAM,yCAAyC,CAG3D,SAAS,EAAO,EAAyD,CACvE,GAAI,CAAC,MAAM,QAAQ,EAAU,CAC3B,MAAO,GAGT,GAAM,CAAC,EAAM,EAAM,GAAG,GAAQ,EAC9B,OACE,OAAO,GAAS,YAChB,EAAK,QAAU,GACf,OAAO,GAAS,YAChB,EAAK,QAAU,GACf,EAAK,SAAW"}