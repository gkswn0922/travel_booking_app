{"version":3,"file":"groupByProp-Xmu8A2SP.js","names":["output: BoundedPartial<\n    Record<AllPropValues<T, Prop>, Array<T[number]>>\n  >"],"sources":["../src/groupByProp.ts"],"sourcesContent":["import type {\n  AllUnionFields,\n  And,\n  ConditionalKeys,\n  IfNever,\n  Merge,\n} from \"type-fest\";\nimport type { ArrayRequiredPrefix } from \"./internal/types/ArrayRequiredPrefix\";\nimport type { BoundedPartial } from \"./internal/types/BoundedPartial\";\nimport type { FilteredArray } from \"./internal/types/FilteredArray\";\nimport type { IterableContainer } from \"./internal/types/IterableContainer\";\nimport type { TupleParts } from \"./internal/types/TupleParts\";\nimport { purry } from \"./purry\";\n\ntype GroupByProp<T extends IterableContainer, Prop extends GroupableProps<T>> =\n  // We distribute the union in order to support unions of tuple types.\n  T extends unknown\n    ? FixEmptyObject<\n        EnsureValuesAreNonEmpty<{\n          // For each possible value of the prop we filter the input tuple with\n          // the prop assigned to the value, e.g. `{ type: \"cat\" }`\n          [Value in AllPropValues<T, Prop>]: FilteredArray<\n            T,\n            Record<Prop, Value>\n          >;\n        }>\n      >\n    : never;\n\n// We can only group by props that only have values that could be used to key\n// an object (i.e. PropertyKey), or if they are undefined (which would filter\n// them out of the grouping).\ntype GroupableProps<T extends IterableContainer> = ConditionalKeys<\n  ItemsSuperObject<T>,\n  PropertyKey | undefined\n>;\n\n// The union of all possible values that the prop could have within the tuple.\ntype AllPropValues<\n  T extends IterableContainer,\n  Prop extends GroupableProps<T>,\n> = Extract<ItemsSuperObject<T>[Prop], PropertyKey>;\n\n// Creates a singular object type that all items in the tuple would extend. This\n// provides us a way to check, for each prop, what are all values it would\n// have within the tuple. We use this to map which props are candidates for\n// grouping, and when a prop is selected, the full list of values that would\n// exist in the output. For example:\n// `{ a: number, b: \"cat\", c: string } | { b: \"dog\", c: Date }` is groupable\n// by 'a' and 'b', but not 'c', and when selecting by 'b', the output would\n// have a prop for \"cat\" and a prop for \"dog\".\ntype ItemsSuperObject<T extends IterableContainer> = AllUnionFields<\n  // If the input tuple contains optional elements they would add `undefined` to\n  // T[number] (and could technically show up in the array itself). Because\n  // undefined breaks AllUnionFields we need to remove it from the union. This\n  // is OK because we handle this in the implementation too.\n  Exclude<T[number], undefined>\n>;\n\n// When the input array is empty the constructed result type would be `{}`\n// because our mapped type would never run; but this doesn't represent the\n// semantics of the return value for that case, because it effectively means\n// \"any object\" and not \"empty object\". This can happen in 2 situations:\n// A union of tuples where one of the tuples doesn't have any item with the\n// groupable prop, or when the groupable prop has a value of `undefined` for\n// all items. The former is extra problematic because it would add `| {}` to the\n// result type which effectively cancels out all other parts of the union.\ntype FixEmptyObject<T> = IfNever<keyof T, Record<PropertyKey, never>, T>;\n\n// Group by can never return an empty tuple but our filtered arrays might not\n// represent that. We need to reshape the tuples so that they always have at\n// least one item in them.\ntype EnsureValuesAreNonEmpty<T extends Record<PropertyKey, IterableContainer>> =\n  Merge<\n    T,\n    BoundedPartial<{\n      [P in keyof T as IsPossiblyEmpty<T[P]> extends true\n        ? P\n        : never]: ArrayRequiredPrefix<T[P], 1>;\n    }>\n  >;\n\n// A tuple is possibly empty if non of the fixed parts have any elements in\n// them. This means the tuple is made of optional elements and/or a rest\n// element.\ntype IsPossiblyEmpty<T extends IterableContainer> = And<\n  IsEmpty<TupleParts<T>[\"required\"]>,\n  IsEmpty<TupleParts<T>[\"suffix\"]>\n>;\n\ntype IsEmpty<T> = T extends readonly [] ? true : false;\n\n/**\n * Groups the elements of an array of objects based on the values of a\n * specified property of those objects. The result would contain a property for\n * each unique value of the specific property, with it's value being the input\n * array filtered to only items that have that property set to that value.\n * For any object where the property is missing, or if it's value is\n * `undefined` the item would be filtered out.\n *\n * The grouping property is enforced at the type level to exist in at least one\n * item and to never have a value that cannot be used as an object key (e.g. it\n * must be `PropertyKey | undefined`).\n *\n * The resulting arrays are filtered with the prop and it's value as a\n * type-guard, effectively narrowing the items in each output arrays. This\n * means that when the grouping property is the discriminator of a\n * discriminated union type each output array would contain just the subtype for\n * that value.\n *\n * If you need more control over the grouping you should use `groupBy` instead.\n *\n * @param data - The items to group.\n * @param prop - The property name to group by.\n * @signature\n *    R.groupByProp(data, prop)\n * @example\n *    const result = R.groupByProp(\n *      //  ^? { cat: [{ a: 'cat' }], dog: [{ a: 'dog' }] }\n *      [{ a: 'cat' }, { a: 'dog' }] as const,\n *      'a',\n *    );\n * @dataFirst\n * @category Array\n */\nexport function groupByProp<\n  T extends IterableContainer,\n  Prop extends GroupableProps<T>,\n>(data: T, prop: Prop): GroupByProp<T, Prop>;\n\n/**\n * Groups the elements of an array of objects based on the values of a\n * specified property of those objects. The result would contain a property for\n * each unique value of the specific property, with it's value being the input\n * array filtered to only items that have that property set to that value.\n * For any object where the property is missing, or if it's value is\n * `undefined` the item would be filtered out.\n *\n * The grouping property is enforced at the type level to exist in at least one\n * item and to never have a value that cannot be used as an object key (e.g. it\n * must be `PropertyKey | undefined`).\n *\n * The resulting arrays are filtered with the prop and it's value as a\n * type-guard, effectively narrowing the items in each output arrays. This\n * means that when the grouping property is the discriminator of a\n * discriminated union type each output array would contain just the subtype for\n * that value.\n *\n * If you need more control over the grouping you should use `groupBy` instead.\n *\n * @param prop - The property name to group by.\n * @signature\n *    R.groupByProp(prop)(data);\n * @example\n *    const result = R.pipe(\n *      //  ^? { cat: [{ a: 'cat' }], dog: [{ a: 'dog' }] }\n *      [{ a: 'cat' }, { a: 'dog' }] as const,\n *      R.groupByProp('a'),\n *    );\n * @dataLast\n * @category Array\n */\nexport function groupByProp<\n  T extends IterableContainer,\n  Prop extends GroupableProps<T>,\n>(prop: Prop): (data: T) => GroupByProp<T, Prop>;\n\nexport function groupByProp(...args: ReadonlyArray<unknown>): unknown {\n  return purry(groupByPropImplementation, args);\n}\n\nfunction groupByPropImplementation<\n  T extends IterableContainer,\n  Prop extends GroupableProps<T>,\n>(data: T, prop: Prop): GroupByProp<T, Prop> {\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment -- Using Object.create(null) allows us to remove everything from the prototype chain, leaving it as a pure object that only has the keys *we* add to it. This prevents issues like the one raised in #1046\n  const output: BoundedPartial<\n    Record<AllPropValues<T, Prop>, Array<T[number]>>\n  > = Object.create(null);\n\n  for (const item of data) {\n    // @ts-expect-error [ts18046] -- `item` should be typed `T[number]` but TypeScript isn't inferring that correctly here, in fact, the item could also be typed as ItemsSuperObject<T> because it extends from it. When item is typed as such this error goes away, maybe in the future TypeScript would be able to infer this by itself.\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment -- Because of the error mentioned above the resulting key isn't inferred correctly as `AllPropValues<T, Prop> | undefined` which would be needed to remove this lint error.\n    const key = item?.[prop];\n    if (key !== undefined) {\n      // Once the prototype chain is fixed, it is safe to access the prop\n      // directly without needing to check existence or types.\n      // @ts-expect-error [ts7053] -- `key` should be typed `AllPropValues<T, Prop>` but TypeScript isn't inferring that correctly, causing an error when we try to access this prop on the output object.\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access -- Because of the error mentioned above the resulting items array isn't being inferred correctly as `Array<T[number]> | undefined` which would be needed to remove this lint error.\n      const items = output[key];\n\n      if (items === undefined) {\n        // It is more performant to create a 1-element array over creating an\n        // empty array and falling through to a unified the push. It is also\n        // more performant to mutate the existing object over using spread to\n        // continually create new objects on every unique key.\n        // @ts-expect-error [ts7053] -- For the same reasons as mentioned above, TypeScript isn't inferring `key` correctly, and therefore is erroring when trying to access the output object using it.\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access -- similarly, because `key` isn't inferred correctly, lint has an issue with us accessing the output object using it.\n        output[key] = [item];\n      } else {\n        // It is more performant to add the items to an existing array instead\n        // of creating a new array via spreading every time we add an item to\n        // it (e.g., `[...current, item]`).\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access -- Similarly to above, because TypeScript didn't infer `items` correctly, lint can't ensure this code is safe and makes sense.\n        items.push(item);\n      }\n    }\n  }\n\n  // Set the prototype as if we initialized our object as a normal object (e.g.\n  // `{}`). Without this none of the built-in object methods like `toString`\n  // would work on this object and it would act differently than expected.\n  Object.setPrototypeOf(output, Object.prototype);\n\n  // @ts-expect-error [ts2322] -- This is fine! We use a broader type for output while we build it because it more accurately represents the shape of the object *while it is being built*. TypeScript can't tell that we finished building the object so can't ensure that output matches the expected output at this point.\n  return output;\n}\n"],"mappings":"4CAuKA,SAAgB,EAAY,GAAG,EAAuC,CACpE,OAAO,EAAM,EAA2B,EAAK,CAG/C,SAAS,EAGP,EAAS,EAAkC,CAE3C,IAAMA,EAEF,OAAO,OAAO,KAAK,CAEvB,IAAK,IAAM,KAAQ,EAAM,CAGvB,IAAM,EAAM,IAAO,GACnB,GAAI,IAAQ,IAAA,GAAW,CAKrB,IAAM,EAAQ,EAAO,GAEjB,IAAU,IAAA,GAOZ,EAAO,GAAO,CAAC,EAAK,CAMpB,EAAM,KAAK,EAAK,EAWtB,OAHA,OAAO,eAAe,EAAQ,OAAO,UAAU,CAGxC"}