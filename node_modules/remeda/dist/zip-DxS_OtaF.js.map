{"version":3,"file":"zip-DxS_OtaF.js","names":[],"sources":["../src/zip.ts"],"sourcesContent":["import type { IterableContainer } from \"./internal/types/IterableContainer\";\nimport type { LazyEvaluator } from \"./internal/types/LazyEvaluator\";\nimport { purry } from \"./purry\";\n\ntype Zipped<Left extends IterableContainer, Right extends IterableContainer> =\n  // If the array is empty the output is empty, no surprises\n  Left extends readonly []\n    ? []\n    : Right extends readonly []\n      ? []\n      : // Are the two inputs both tuples with a non-rest first item?\n        Left extends readonly [infer LeftHead, ...infer LeftRest]\n        ? Right extends readonly [infer RightHead, ...infer RightRest]\n          ? // ...Then take that first item from both and recurse\n            [[LeftHead, RightHead], ...Zipped<LeftRest, RightRest>]\n          : // Is only one of the inputs a tuple (with a non-rest first item)?\n            // Then take that item, and match it with whatever the type of the other *array's* items are.\n            [[LeftHead, Right[number]], ...Zipped<LeftRest, Right>]\n        : Right extends readonly [infer RightHead, ...infer RightRest]\n          ? [[Left[number], RightHead], ...Zipped<Left, RightRest>]\n          : // Both inputs are not tuples (with a non-rest first item, they might be tuples with non-rest last item(s))\n            // So the output is just the \"trivial\" zip result.\n            Array<[Left[number], Right[number]]>;\n\n/**\n * Creates a new list from two supplied lists by pairing up equally-positioned\n * items. The length of the returned list will match the shortest of the two\n * inputs.\n *\n * @param first - The first input list.\n * @param second - The second input list.\n * @signature\n *   R.zip(first, second)\n * @example\n *   R.zip([1, 2], ['a', 'b']) // => [[1, 'a'], [2, 'b']]\n * @dataFirst\n * @lazy\n * @category Array\n */\nexport function zip<F extends IterableContainer, S extends IterableContainer>(\n  first: F,\n  second: S,\n): Zipped<F, S>;\n\n/**\n * Creates a new list from two supplied lists by pairing up equally-positioned\n * items. The length of the returned list will match the shortest of the two\n * inputs.\n *\n * @param second - The second input list.\n * @signature\n *   R.zip(second)(first)\n * @example\n *   R.zip(['a', 'b'])([1, 2]) // => [[1, 'a'], [2, 'b']]\n * @dataLast\n * @lazy\n * @category Array\n */\nexport function zip<S extends IterableContainer>(\n  second: S,\n): <F extends IterableContainer>(first: F) => Zipped<F, S>;\n\nexport function zip(...args: ReadonlyArray<unknown>): unknown {\n  return purry(zipImplementation, args, lazyImplementation);\n}\n\nconst zipImplementation = <\n  F extends IterableContainer,\n  S extends IterableContainer,\n>(\n  first: F,\n  second: S,\n): Zipped<F, S> =>\n  (first.length < second.length\n    ? first.map((item, index) => [item, second[index]])\n    : second.map((item, index) => [first[index], item])) as Zipped<F, S>;\n\nconst lazyImplementation =\n  <F extends IterableContainer, S extends IterableContainer>(\n    second: S,\n  ): LazyEvaluator<F[number], [F[number], S[number]]> =>\n  (value, index) => ({\n    hasNext: true,\n    next: [value, second[index]],\n    done: index >= second.length - 1,\n  });\n"],"mappings":"4CA8DA,SAAgB,EAAI,GAAG,EAAuC,CAC5D,OAAO,EAAM,EAAmB,EAAM,EAAmB,CAG3D,MAAM,GAIJ,EACA,IAEC,EAAM,OAAS,EAAO,OACnB,EAAM,KAAK,EAAM,IAAU,CAAC,EAAM,EAAO,GAAO,CAAC,CACjD,EAAO,KAAK,EAAM,IAAU,CAAC,EAAM,GAAQ,EAAK,CAAC,CAEjD,EAEF,IAED,EAAO,KAAW,CACjB,QAAS,GACT,KAAM,CAAC,EAAO,EAAO,GAAO,CAC5B,KAAM,GAAS,EAAO,OAAS,EAChC"}