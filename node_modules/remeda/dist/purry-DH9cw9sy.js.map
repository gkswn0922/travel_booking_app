{"version":3,"file":"purry-DH9cw9sy.js","names":[],"sources":["../src/purry.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\n\nimport { lazyDataLastImpl } from \"./internal/lazyDataLastImpl\";\nimport type { LazyEvaluator } from \"./internal/types/LazyEvaluator\";\nimport type { StrictFunction } from \"./internal/types/StrictFunction\";\n\n/**\n * Creates a function with `dataFirst` and `dataLast` signatures.\n *\n * `purry` is a dynamic function and it's not type safe. It should be wrapped by\n * a function that have proper typings. Refer to the example below for correct\n * usage.\n *\n * !IMPORTANT: functions that simply call `purry` and return the result (like\n * almost all functions in this library) should return `unknown` themselves if\n * an explicit return type is required. This is because we currently don't\n * provide a generic return type that is built from the input function, and\n * crafting one manually isn't worthwhile as we rely on function declaration\n * overloading to combine the types for dataFirst and dataLast invocations!\n *\n * @param fn - The function to purry.\n * @param args - The arguments.\n * @param lazy - A lazy version of the function to purry.\n * @signature R.purry(fn, args);\n * @example\n *    function _findIndex(array, fn) {\n *      for (let i = 0; i < array.length; i++) {\n *        if (fn(array[i])) {\n *          return i;\n *        }\n *      }\n *      return -1;\n *    }\n *\n *    // data-first\n *    function findIndex<T>(array: T[], fn: (item: T) => boolean): number;\n *\n *    // data-last\n *    function findIndex<T>(fn: (item: T) => boolean): (array: T[]) => number;\n *\n *    function findIndex(...args: unknown[]) {\n *      return R.purry(_findIndex, args);\n *    }\n * @category Function\n */\nexport function purry(\n  fn: StrictFunction,\n  args: ReadonlyArray<unknown>,\n  lazy?: (...args: any) => LazyEvaluator,\n): unknown {\n  const diff = fn.length - args.length;\n  if (diff === 0) {\n    // @ts-expect-error [ts2345] -- This error is accurate because we don't know\n    // anything about `fn` so can't ensure that we are passing the correct\n    // arguments to it, we just have to trust that the caller knows what they\n    // are doing.\n    return fn(...args);\n  }\n\n  if (diff === 1) {\n    return lazyDataLastImpl(fn, args, lazy);\n  }\n\n  throw new Error(\"Wrong number of arguments\");\n}\n"],"mappings":"kEA6CA,SAAgB,EACd,EACA,EACA,EACS,CACT,IAAM,EAAO,EAAG,OAAS,EAAK,OAC9B,GAAI,IAAS,EAKX,OAAO,EAAG,GAAG,EAAK,CAGpB,GAAI,IAAS,EACX,OAAO,EAAiB,EAAI,EAAM,EAAK,CAGzC,MAAU,MAAM,4BAA4B"}