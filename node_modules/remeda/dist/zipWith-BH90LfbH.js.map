{"version":3,"file":"zipWith-BH90LfbH.js","names":[],"sources":["../src/zipWith.ts"],"sourcesContent":["import { lazyDataLastImpl } from \"./internal/lazyDataLastImpl\";\nimport type { IterableContainer } from \"./internal/types/IterableContainer\";\nimport type { LazyEvaluator } from \"./internal/types/LazyEvaluator\";\n\ntype ZippingFunction<\n  T1 extends IterableContainer = IterableContainer,\n  T2 extends IterableContainer = IterableContainer,\n  Value = unknown,\n> = (\n  first: T1[number],\n  second: T2[number],\n  index: number,\n  data: readonly [first: T1, second: T2],\n) => Value;\n\n/**\n * Creates a new list from two supplied lists by calling the supplied function\n * with the same-positioned element from each list.\n *\n * @param fn - The function applied to each position of the list.\n * @signature\n *   R.zipWith(fn)(first, second)\n * @example\n *   R.zipWith((a: string, b: string) => a + b)(['1', '2', '3'], ['a', 'b', 'c']) // => ['1a', '2b', '3c']\n * @category Array\n */\nexport function zipWith<TItem1, TItem2, Value>(\n  fn: ZippingFunction<ReadonlyArray<TItem1>, ReadonlyArray<TItem2>, Value>,\n): (\n  first: ReadonlyArray<TItem1>,\n  second: ReadonlyArray<TItem2>,\n) => Array<Value>;\n\n/**\n * Creates a new list from two supplied lists by calling the supplied function\n * with the same-positioned element from each list.\n *\n * @param second - The second input list.\n * @param fn - The function applied to each position of the list.\n * @signature\n *   R.zipWith(second, fn)(first)\n * @example\n *   R.pipe(['1', '2', '3'], R.zipWith(['a', 'b', 'c'], (a, b) => a + b)) // => ['1a', '2b', '3c']\n * @dataLast\n * @lazy\n * @category Array\n */\nexport function zipWith<\n  T1 extends IterableContainer,\n  T2 extends IterableContainer,\n  Value,\n>(second: T2, fn: ZippingFunction<T1, T2, Value>): (first: T1) => Array<Value>;\n\n/**\n * Creates a new list from two supplied lists by calling the supplied function\n * with the same-positioned element from each list.\n *\n * @param first - The first input list.\n * @param second - The second input list.\n * @param fn - The function applied to each position of the list.\n * @signature\n *   R.zipWith(first, second, fn)\n * @example\n *   R.zipWith(['1', '2', '3'], ['a', 'b', 'c'], (a, b) => a + b) // => ['1a', '2b', '3c']\n * @dataFirst\n * @lazy\n * @category Array\n */\nexport function zipWith<\n  T1 extends IterableContainer,\n  T2 extends IterableContainer,\n  Value,\n>(first: T1, second: T2, fn: ZippingFunction<T1, T2, Value>): Array<Value>;\n\nexport function zipWith(\n  arg0: IterableContainer | ZippingFunction,\n  arg1?: IterableContainer | ZippingFunction,\n  arg2?: ZippingFunction,\n): unknown {\n  if (typeof arg0 === \"function\") {\n    // Both datum's last\n    return (data1: IterableContainer, data2: IterableContainer) =>\n      zipWithImplementation(data1, data2, arg0);\n  }\n\n  if (typeof arg1 === \"function\") {\n    // dataLast\n    return lazyDataLastImpl(\n      zipWithImplementation,\n      [arg0, arg1],\n      lazyImplementation,\n    );\n  }\n\n  // dataFirst. Notice that we assert that the arguments are defined to reduce\n  // the number of runtime checks that would otherwise be needed to make\n  // TypeScript happy here. Because this is an internal implementation and we\n  // are protected by the function typing itself this is fine!\n  return zipWithImplementation(arg0, arg1!, arg2!);\n}\n\nfunction zipWithImplementation<\n  T1 extends IterableContainer,\n  T2 extends IterableContainer,\n  Value,\n>(first: T1, second: T2, fn: ZippingFunction<T1, T2, Value>): Array<Value> {\n  const datum = [first, second] as const;\n  return first.length < second.length\n    ? first.map((item, index) => fn(item, second[index], index, datum))\n    : second.map((item, index) => fn(first[index], item, index, datum));\n}\n\nconst lazyImplementation =\n  <T1, T2 extends IterableContainer, Value>(\n    second: T2,\n    fn: ZippingFunction<ReadonlyArray<T1>, T2, Value>,\n  ): LazyEvaluator<T1, Value> =>\n  (value, index, data) => ({\n    next: fn(value, second[index], index, [data, second]),\n    hasNext: true,\n    done: index >= second.length - 1,\n  });\n"],"mappings":"kEA0EA,SAAgB,EACd,EACA,EACA,EACS,CAoBT,OAnBI,OAAO,GAAS,YAEV,EAA0B,IAChC,EAAsB,EAAO,EAAO,EAAK,CAGzC,OAAO,GAAS,WAEX,EACL,EACA,CAAC,EAAM,EAAK,CACZ,EACD,CAOI,EAAsB,EAAM,EAAO,EAAM,CAGlD,SAAS,EAIP,EAAW,EAAY,EAAkD,CACzE,IAAM,EAAQ,CAAC,EAAO,EAAO,CAC7B,OAAO,EAAM,OAAS,EAAO,OACzB,EAAM,KAAK,EAAM,IAAU,EAAG,EAAM,EAAO,GAAQ,EAAO,EAAM,CAAC,CACjE,EAAO,KAAK,EAAM,IAAU,EAAG,EAAM,GAAQ,EAAM,EAAO,EAAM,CAAC,CAGvE,MAAM,GAEF,EACA,KAED,EAAO,EAAO,KAAU,CACvB,KAAM,EAAG,EAAO,EAAO,GAAQ,EAAO,CAAC,EAAM,EAAO,CAAC,CACrD,QAAS,GACT,KAAM,GAAS,EAAO,OAAS,EAChC"}