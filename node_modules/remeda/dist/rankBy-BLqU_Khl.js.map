{"version":3,"file":"rankBy-BLqU_Khl.js","names":[],"sources":["../src/rankBy.ts"],"sourcesContent":["import {\n  purryOrderRulesWithArgument,\n  type OrderRule,\n} from \"./internal/purryOrderRules\";\nimport type { CompareFunction } from \"./internal/types/CompareFunction\";\nimport type { NonEmptyArray } from \"./internal/types/NonEmptyArray\";\n\n/**\n * Calculates the rank of an item in an array based on `rules`. The rank is the position where the item would appear in the sorted array. This function provides an efficient way to determine the rank in *O(n)* time, compared to *O(nlogn)* for the equivalent `sortedIndex(sortBy(data, ...rules), item)`.\n *\n * @param data - The input array.\n * @param item - The item whose rank is to be determined.\n * @param rules - A variadic array of order rules defining the sorting criteria. Each order rule is a projection function that extracts a comparable value from the data. Sorting is based on these extracted values using the native `<` and `>` operators. Earlier rules take precedence over later ones. Use the syntax `[projection, \"desc\"]` for descending order.\n * @returns The rank of the item in the sorted array in the range [0..data.length].\n * @signature\n *   R.rankBy(data, item, ...rules)\n * @example\n *   const DATA = [{ a: 5 }, { a: 1 }, { a: 3 }] as const;\n *   R.rankBy(DATA, 0, R.prop('a')) // => 0\n *   R.rankBy(DATA, 1, R.prop('a')) // => 1\n *   R.rankBy(DATA, 2, R.prop('a')) // => 1\n *   R.rankBy(DATA, 3, R.prop('a')) // => 2\n * @dataFirst\n * @category Array\n */\nexport function rankBy<T>(\n  data: ReadonlyArray<T>,\n  item: T,\n  ...rules: Readonly<NonEmptyArray<OrderRule<T>>>\n): number;\n\n/**\n * Calculates the rank of an item in an array based on `rules`. The rank is the position where the item would appear in the sorted array. This function provides an efficient way to determine the rank in *O(n)* time, compared to *O(nlogn)* for the equivalent `sortedIndex(sortBy(data, ...rules), item)`.\n *\n * @param item - The item whose rank is to be determined.\n * @param rules - A variadic array of order rules defining the sorting criteria. Each order rule is a projection function that extracts a comparable value from the data. Sorting is based on these extracted values using the native `<` and `>` operators. Earlier rules take precedence over later ones. Use the syntax `[projection, \"desc\"]` for descending order.\n * @returns The rank of the item in the sorted array in the range [0..data.length].\n * @signature\n *   R.rankBy(item, ...rules)(data)\n * @example\n *   const DATA = [{ a: 5 }, { a: 1 }, { a: 3 }] as const;\n *   R.pipe(DATA, R.rankBy(0, R.prop('a'))) // => 0\n *   R.pipe(DATA, R.rankBy(1, R.prop('a'))) // => 1\n *   R.pipe(DATA, R.rankBy(2, R.prop('a'))) // => 1\n *   R.pipe(DATA, R.rankBy(3, R.prop('a'))) // => 2\n * @dataLast\n * @category Array\n */\nexport function rankBy<T>(\n  item: T,\n  ...rules: Readonly<NonEmptyArray<OrderRule<T>>>\n): (data: ReadonlyArray<T>) => number;\n\nexport function rankBy(...args: ReadonlyArray<unknown>): unknown {\n  return purryOrderRulesWithArgument(rankByImplementation, args);\n}\n\nfunction rankByImplementation<T>(\n  data: ReadonlyArray<T>,\n  compareFn: CompareFunction<T>,\n  targetItem: T,\n): number {\n  let rank = 0;\n  for (const item of data) {\n    if (compareFn(targetItem, item) > 0) {\n      // The rank of the item is equivalent to the number of items that would\n      // come before it if the array was sorted. We assume that the\n      rank += 1;\n    }\n  }\n  return rank;\n}\n"],"mappings":"4EAqDA,SAAgB,EAAO,GAAG,EAAuC,CAC/D,OAAO,EAA4B,EAAsB,EAAK,CAGhE,SAAS,EACP,EACA,EACA,EACQ,CACR,IAAI,EAAO,EACX,IAAK,IAAM,KAAQ,EACb,EAAU,EAAY,EAAK,CAAG,IAGhC,GAAQ,GAGZ,OAAO"}