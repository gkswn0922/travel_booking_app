{"version":3,"file":"partition-DAu403JQ.js","names":["ret: [Array<S>, Array<T>]"],"sources":["../src/partition.ts"],"sourcesContent":["import { purry } from \"./purry\";\n\n/**\n * Splits a collection into two groups, the first of which contains elements the\n * `predicate` type guard passes, and the second one containing the rest.\n *\n * @param data - The items to split.\n * @param predicate - A function to execute for each element in the array. It\n * should return `true` to add the element to the first partition, and and\n * `false` to add the element to the other partition. A type-predicate can also\n * be used to narrow the result.\n * @returns A 2-tuple of arrays where the first array contains the elements that\n * passed the predicate, and the second array contains the elements that did\n * not. The items are in the same order as they were in the original array.\n * @signature\n *    R.partition(data, predicate)\n * @example\n *    R.partition(\n *      ['one', 'two', 'forty two'],\n *      x => x.length === 3,\n *    ); // => [['one', 'two'], ['forty two']]\n * @dataFirst\n * @category Array\n */\nexport function partition<T, S extends T>(\n  data: ReadonlyArray<T>,\n  predicate: (value: T, index: number, data: ReadonlyArray<T>) => value is S,\n): [Array<S>, Array<Exclude<T, S>>];\nexport function partition<T>(\n  data: ReadonlyArray<T>,\n  predicate: (value: T, index: number, data: ReadonlyArray<T>) => boolean,\n): [Array<T>, Array<T>];\n\n/**\n * Splits a collection into two groups, the first of which contains elements the\n * `predicate` type guard passes, and the second one containing the rest.\n *\n * @param predicate - A function to execute for each element in the array. It\n * should return `true` to add the element to the first partition, and and\n * `false` to add the element to the other partition. A type-predicate can also\n * be used to narrow the result.\n * @returns A 2-tuple of arrays where the first array contains the elements that\n * passed the predicate, and the second array contains the elements that did\n * not. The items are in the same order as they were in the original array.\n * @signature\n *    R.partition(predicate)(data)\n * @example\n *    R.pipe(\n *      ['one', 'two', 'forty two'],\n *      R.partition(x => x.length === 3),\n *    ); // => [['one', 'two'], ['forty two']]\n * @dataLast\n * @category Array\n */\nexport function partition<T, S extends T>(\n  predicate: (value: T, index: number, data: ReadonlyArray<T>) => value is S,\n): (data: ReadonlyArray<T>) => [Array<S>, Array<Exclude<T, S>>];\nexport function partition<T>(\n  predicate: (value: T, index: number, data: ReadonlyArray<T>) => boolean,\n): (data: ReadonlyArray<T>) => [Array<T>, Array<T>];\n\nexport function partition(...args: ReadonlyArray<unknown>): unknown {\n  return purry(partitionImplementation, args);\n}\n\nconst partitionImplementation = <T, S extends T>(\n  data: ReadonlyArray<T>,\n  predicate: (value: T, index: number, data: ReadonlyArray<T>) => value is S,\n): [Array<S>, Array<T>] => {\n  const ret: [Array<S>, Array<T>] = [[], []];\n  for (const [index, item] of data.entries()) {\n    if (predicate(item, index, data)) {\n      ret[0].push(item);\n    } else {\n      ret[1].push(item);\n    }\n  }\n  return ret;\n};\n"],"mappings":"4CA6DA,SAAgB,EAAU,GAAG,EAAuC,CAClE,OAAO,EAAM,EAAyB,EAAK,CAG7C,MAAM,GACJ,EACA,IACyB,CACzB,IAAMA,EAA4B,CAAC,EAAE,CAAE,EAAE,CAAC,CAC1C,IAAK,GAAM,CAAC,EAAO,KAAS,EAAK,SAAS,CACpC,EAAU,EAAM,EAAO,EAAK,CAC9B,EAAI,GAAG,KAAK,EAAK,CAEjB,EAAI,GAAG,KAAK,EAAK,CAGrB,OAAO"}