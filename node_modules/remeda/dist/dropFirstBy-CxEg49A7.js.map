{"version":3,"file":"dropFirstBy-CxEg49A7.js","names":[],"sources":["../src/dropFirstBy.ts"],"sourcesContent":["import { heapify, heapMaybeInsert } from \"./internal/heap\";\nimport {\n  purryOrderRulesWithArgument,\n  type OrderRule,\n} from \"./internal/purryOrderRules\";\nimport type { CompareFunction } from \"./internal/types/CompareFunction\";\nimport type { NonEmptyArray } from \"./internal/types/NonEmptyArray\";\n\n/**\n * Drop the first `n` items from `data` based on the provided ordering criteria. This allows you to avoid sorting the array before dropping the items. The complexity of this function is *O(Nlogn)* where `N` is the length of the array.\n *\n * For the opposite operation (to keep `n` elements) see `takeFirstBy`.\n *\n * @param data - The input array.\n * @param n - The number of items to drop. If `n` is non-positive no items would be dropped and a *clone* of the input would be returned, if `n` is bigger then data.length no items would be returned.\n * @param rules - A variadic array of order rules defining the sorting criteria. Each order rule is a projection function that extracts a comparable value from the data. Sorting is based on these extracted values using the native `<` and `>` operators. Earlier rules take precedence over later ones. Use the syntax `[projection, \"desc\"]` for descending order.\n * @returns A subset of the input array.\n * @signature\n *   R.dropFirstBy(data, n, ...rules);\n * @example\n *   R.dropFirstBy(['aa', 'aaaa', 'a', 'aaa'], 2, x => x.length); // => ['aaa', 'aaaa']\n * @dataFirst\n * @category Array\n */\nexport function dropFirstBy<T>(\n  data: ReadonlyArray<T>,\n  n: number,\n  ...rules: Readonly<NonEmptyArray<OrderRule<T>>>\n): Array<T>;\n\n/**\n * Drop the first `n` items from `data` based on the provided ordering criteria. This allows you to avoid sorting the array before dropping the items. The complexity of this function is *O(Nlogn)* where `N` is the length of the array.\n *\n * For the opposite operation (to keep `n` elements) see `takeFirstBy`.\n *\n * @param n - The number of items to drop. If `n` is non-positive no items would be dropped and a *clone* of the input would be returned, if `n` is bigger then data.length no items would be returned.\n * @param rules - A variadic array of order rules defining the sorting criteria. Each order rule is a projection function that extracts a comparable value from the data. Sorting is based on these extracted values using the native `<` and `>` operators. Earlier rules take precedence over later ones. Use the syntax `[projection, \"desc\"]` for descending order.\n * @returns A subset of the input array.\n * @signature\n *   R.dropFirstBy(n, ...rules)(data);\n * @example\n *   R.pipe(['aa', 'aaaa', 'a', 'aaa'], R.dropFirstBy(2, x => x.length)); // => ['aaa', 'aaaa']\n * @dataLast\n * @category Array\n */\nexport function dropFirstBy<T>(\n  n: number,\n  ...rules: Readonly<NonEmptyArray<OrderRule<T>>>\n): (data: ReadonlyArray<T>) => Array<T>;\n\nexport function dropFirstBy(...args: ReadonlyArray<unknown>): unknown {\n  return purryOrderRulesWithArgument(dropFirstByImplementation, args);\n}\n\nfunction dropFirstByImplementation<T>(\n  data: ReadonlyArray<T>,\n  compareFn: CompareFunction<T>,\n  n: number,\n): Array<T> {\n  if (n >= data.length) {\n    return [];\n  }\n\n  if (n <= 0) {\n    return [...data];\n  }\n\n  const heap = data.slice(0, n);\n  heapify(heap, compareFn);\n\n  const out = [];\n\n  const rest = data.slice(n);\n  for (const item of rest) {\n    const previousHead = heapMaybeInsert(heap, compareFn, item);\n    out.push(previousHead ?? item);\n  }\n\n  return out;\n}\n"],"mappings":"8IAkDA,SAAgB,EAAY,GAAG,EAAuC,CACpE,OAAO,EAA4B,EAA2B,EAAK,CAGrE,SAAS,EACP,EACA,EACA,EACU,CACV,GAAI,GAAK,EAAK,OACZ,MAAO,EAAE,CAGX,GAAI,GAAK,EACP,MAAO,CAAC,GAAG,EAAK,CAGlB,IAAM,EAAO,EAAK,MAAM,EAAG,EAAE,CAC7B,EAAQ,EAAM,EAAU,CAExB,IAAM,EAAM,EAAE,CAER,EAAO,EAAK,MAAM,EAAE,CAC1B,IAAK,IAAM,KAAQ,EAAM,CACvB,IAAM,EAAe,EAAgB,EAAM,EAAW,EAAK,CAC3D,EAAI,KAAK,GAAgB,EAAK,CAGhC,OAAO"}