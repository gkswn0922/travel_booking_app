{"version":3,"file":"mean-l3vFO5Bo.js","names":[],"sources":["../src/mean.ts"],"sourcesContent":["import type { IterableContainer } from \"./internal/types/IterableContainer\";\nimport { purry } from \"./purry\";\nimport { sum } from \"./sum\";\n\ntype Mean<T extends IterableContainer<number>> =\n  | (T extends readonly [] ? never : number)\n  | (T extends readonly [unknown, ...Array<unknown>] ? never : undefined);\n\n/**\n * Returns the mean of the elements of an array.\n *\n * Only `number` arrays are supported, as `bigint` is unable to represent fractional values.\n *\n * IMPORTANT: The result for empty arrays would be `undefined`, regardless of\n * the type of the array. This approach improves type-checking and ensures that\n * cases where `NaN` might occur are handled properly. To avoid adding this to\n * the return type for cases where the array is known to be non-empty you can use\n * `hasAtLeast` or `isEmpty` to guard against this case.\n *\n * @param data - The array of numbers.\n * @signature\n *   R.mean(data);\n * @example\n *   R.mean([1, 2, 3]); // => 2\n *   R.mean([]); // => undefined\n * @dataFirst\n * @category Number\n */\nexport function mean<T extends IterableContainer<number>>(data: T): Mean<T>;\n\n/**\n * Returns the mean of the elements of an array.\n *\n * Only `number` arrays are supported, as `bigint` is unable to represent fractional values.\n *\n * IMPORTANT: The result for empty arrays would be `undefined`, regardless of\n * the type of the array. This approach improves type-checking and ensures that\n * cases where `NaN` might occur are handled properly. To avoid adding this to\n * the return type for cases where the array is known to be non-empty you can use\n * `hasAtLeast` or `isEmpty` to guard against this case.\n *\n * @signature\n *   R.mean()(data);\n * @example\n *   R.pipe([1, 2, 3], R.mean()); // => 2\n *   R.pipe([], R.mean()); // => undefined\n * @dataLast\n * @category Number\n */\nexport function mean(): <T extends IterableContainer<number>>(\n  data: T,\n) => Mean<T>;\n\nexport function mean(...args: ReadonlyArray<unknown>): unknown {\n  return purry(meanImplementation, args);\n}\n\nfunction meanImplementation<T extends IterableContainer<number>>(\n  data: T,\n): T[number] | undefined {\n  if (data.length === 0) {\n    return undefined;\n  }\n\n  return sum(data) / data.length;\n}\n"],"mappings":"oFAqDA,SAAgB,EAAK,GAAG,EAAuC,CAC7D,OAAO,EAAM,EAAoB,EAAK,CAGxC,SAAS,EACP,EACuB,CACnB,KAAK,SAAW,EAIpB,OAAO,EAAI,EAAK,CAAG,EAAK"}