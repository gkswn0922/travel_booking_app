{"version":3,"file":"takeFirstBy-CWZxOHpF.js","names":[],"sources":["../src/takeFirstBy.ts"],"sourcesContent":["import { heapify, heapMaybeInsert } from \"./internal/heap\";\nimport {\n  purryOrderRulesWithArgument,\n  type OrderRule,\n} from \"./internal/purryOrderRules\";\nimport type { CompareFunction } from \"./internal/types/CompareFunction\";\nimport type { NonEmptyArray } from \"./internal/types/NonEmptyArray\";\n\n/**\n * Take the first `n` items from `data` based on the provided ordering criteria. This allows you to avoid sorting the array before taking the items. The complexity of this function is *O(Nlogn)* where `N` is the length of the array.\n *\n * For the opposite operation (to drop `n` elements) see `dropFirstBy`.\n *\n * @param data - The input array.\n * @param n - The number of items to take. If `n` is non-positive no items would be returned, if `n` is bigger then data.length a *clone* of `data` would be returned.\n * @param rules - A variadic array of order rules defining the sorting criteria. Each order rule is a projection function that extracts a comparable value from the data. Sorting is based on these extracted values using the native `<` and `>` operators. Earlier rules take precedence over later ones. Use the syntax `[projection, \"desc\"]` for descending order.\n * @returns A subset of the input array.\n * @signature\n *   R.takeFirstBy(data, n, ...rules);\n * @example\n *   R.takeFirstBy(['aa', 'aaaa', 'a', 'aaa'], 2, x => x.length); // => ['a', 'aa']\n * @dataFirst\n * @category Array\n */\nexport function takeFirstBy<T>(\n  data: ReadonlyArray<T>,\n  n: number,\n  ...rules: Readonly<NonEmptyArray<OrderRule<T>>>\n): Array<T>;\n\n/**\n * Take the first `n` items from `data` based on the provided ordering criteria. This allows you to avoid sorting the array before taking the items. The complexity of this function is *O(Nlogn)* where `N` is the length of the array.\n *\n * For the opposite operation (to drop `n` elements) see `dropFirstBy`.\n *\n * @param n - The number of items to take. If `n` is non-positive no items would be returned, if `n` is bigger then data.length a *clone* of `data` would be returned.\n * @param rules - A variadic array of order rules defining the sorting criteria. Each order rule is a projection function that extracts a comparable value from the data. Sorting is based on these extracted values using the native `<` and `>` operators. Earlier rules take precedence over later ones. Use the syntax `[projection, \"desc\"]` for descending order.\n * @returns A subset of the input array.\n * @signature\n *   R.takeFirstBy(n, ...rules)(data);\n * @example\n *   R.pipe(['aa', 'aaaa', 'a', 'aaa'], R.takeFirstBy(2, x => x.length)); // => ['a', 'aa']\n * @dataLast\n * @category Array\n */\nexport function takeFirstBy<T>(\n  n: number,\n  ...rules: Readonly<NonEmptyArray<OrderRule<T>>>\n): (data: ReadonlyArray<T>) => Array<T>;\n\nexport function takeFirstBy(...args: ReadonlyArray<unknown>): unknown {\n  return purryOrderRulesWithArgument(takeFirstByImplementation, args);\n}\n\nfunction takeFirstByImplementation<T>(\n  data: ReadonlyArray<T>,\n  compareFn: CompareFunction<T>,\n  n: number,\n): Array<T> {\n  if (n <= 0) {\n    return [];\n  }\n\n  if (n >= data.length) {\n    return [...data];\n  }\n\n  const heap = data.slice(0, n);\n  heapify(heap, compareFn);\n\n  const rest = data.slice(n);\n  for (const item of rest) {\n    heapMaybeInsert(heap, compareFn, item);\n  }\n\n  return heap;\n}\n"],"mappings":"8IAkDA,SAAgB,EAAY,GAAG,EAAuC,CACpE,OAAO,EAA4B,EAA2B,EAAK,CAGrE,SAAS,EACP,EACA,EACA,EACU,CACV,GAAI,GAAK,EACP,MAAO,EAAE,CAGX,GAAI,GAAK,EAAK,OACZ,MAAO,CAAC,GAAG,EAAK,CAGlB,IAAM,EAAO,EAAK,MAAM,EAAG,EAAE,CAC7B,EAAQ,EAAM,EAAU,CAExB,IAAM,EAAO,EAAK,MAAM,EAAE,CAC1B,IAAK,IAAM,KAAQ,EACjB,EAAgB,EAAM,EAAW,EAAK,CAGxC,OAAO"}