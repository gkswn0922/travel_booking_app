{"version":3,"file":"sortedIndex-CQhzGRfq.js","names":[],"sources":["../src/sortedIndex.ts"],"sourcesContent":["import { purry } from \"./purry\";\nimport { binarySearchCutoffIndex } from \"./internal/binarySearchCutoffIndex\";\n\n/**\n * Find the insertion position (index) of an item in an array with items sorted\n * in ascending order; so that `splice(sortedIndex, 0, item)` would result in\n * maintaining the array's sort-ness. The array can contain duplicates.\n * If the item already exists in the array the index would be of the *first*\n * occurrence of the item.\n *\n * Runs in O(logN) time.\n *\n * @param data - The (ascending) sorted array.\n * @param item - The item to insert.\n * @returns Insertion index (In the range 0..array.length).\n * @signature\n *    R.sortedIndex(data, item)\n * @example\n *    R.sortedIndex(['a','a','b','c','c'], 'c') // => 3\n * @dataFirst\n * @category Array\n * @see sortedIndexBy, sortedIndexWith, sortedLastIndex, sortedLastIndexBy\n */\nexport function sortedIndex<T>(data: ReadonlyArray<T>, item: T): number;\n\n/**\n * Find the insertion position (index) of an item in an array with items sorted\n * in ascending order; so that `splice(sortedIndex, 0, item)` would result in\n * maintaining the array's sort-ness. The array can contain duplicates.\n * If the item already exists in the array the index would be of the *first*\n * occurrence of the item.\n *\n * Runs in O(logN) time.\n *\n * @param item - The item to insert.\n * @returns Insertion index (In the range 0..array.length).\n * @signature\n *    R.sortedIndex(item)(data)\n * @example\n *    R.pipe(['a','a','b','c','c'], R.sortedIndex('c')) // => 3\n * @dataLast\n * @category Array\n * @see sortedIndexBy, sortedIndexWith, sortedLastIndex, sortedLastIndexBy\n */\nexport function sortedIndex<T>(item: T): (data: ReadonlyArray<T>) => number;\n\nexport function sortedIndex(...args: ReadonlyArray<unknown>): unknown {\n  return purry(sortedIndexImplementation, args);\n}\n\nconst sortedIndexImplementation = <T>(\n  array: ReadonlyArray<T>,\n  item: T,\n): number => binarySearchCutoffIndex(array, (pivot) => pivot < item);\n"],"mappings":"4HA8CA,SAAgB,EAAY,GAAG,EAAuC,CACpE,OAAO,EAAM,EAA2B,EAAK,CAG/C,MAAM,GACJ,EACA,IACW,EAAwB,EAAQ,GAAU,EAAQ,EAAK"}